# Java进阶训练营毕业项目

## JVM
Java语言是运行时跨平台的语言。JVM是为实现这一特性而诞生的。不同的平台会有不同的JVM来隔离平台的区别来执行同样的代码。Java文件有编译器编译成CLASS文件。主类执行时会启动一个JVM实例，
然后CLASSLOADER会按需加载CLASSPATH的Class文件或者JAR包。Class对象存在于方法区，实例存在于堆内存中。每启动一个线程，JVM就会在栈空间中分配对应的线程栈。
每个栈帧对应一个方法调用，存有出入参，局部变量，Class指针等等。 由于内存大小有限，不再需要的内存空间通过可达性分析被回收。具体操作时从GC ROOT对象出发，
标记它们能够调用的对象，来标记可达对象，最后清理和整理。通常的垃圾回收策略有Serial, CMS，Parallel， G1, ZGC. 通常堆内存会分成年轻代(Eden, Surviors)和老年代. 不同的代会采用不同的回收策略。
常用的工具有jps, jstat, jstack, jmap, jconsole, jvisualvm, jmc等来查看JVM运行是java进程对系统资源的使用情况。

## NIO
NIO的基本模块有Channels, Buffers和Selectors。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，
数据从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。

学习了何为高性能，高性能可以分为高并发，高吞吐和低延迟。对此学习了NETTY,它是一个异步，事件驱动，基于NIO的网络应用开发框架。
Reactor模型分为单线程，非主从多线程和主从多线程模式。 NETTY都提供了支持。API网关的四大职能是请求接入， 业务聚合，中介策略，统一管理。网关还分为流量网关和业务网关，前者偏向稳定和安全，后者偏向服务。

典型的API网关有Zuul和Spring Cloud Gateway.

## 并发编程
多CPU核心意味着JVM可以并行的使用计算资源，也由此带来了线程安全问题，提高了JAVA应用的复杂度。
线程安全问题主要分成，原子性（操作不可中断）， 有序性 （编译器和CPU不可对指令重排序），可见性（CPU缓存和主存的数据不一致。
这些问题可以通过加锁解决。 JDK对多线程编程提供了线程池，其接口主要分成Executor（接口）， ExecutorService （执行器）, ThreadFactory（线程工厂）和Executors（工具类）.

## Spring 和 ORM 等框架
Spring为简化EJB而生，而Spring Boot为简化Spring而生。它的两大核心原理是自动化配置(Configuration, Condition, 等等），脚手架核心（Spring-Boot-Starter). 

JDBC是Java为数据库交互提供的定义。主要的类有DriverManager, Connection, Statement, ResultSet. 
Hiberate and Mybatis对JDBC进行了封装，自动或者通过注解和XML来实现了实体类到数据库表字段的映射。
由此可以自动或者通过XML和注解的方式配置SQL。 Spring通过事务管理器加上AOP无侵入式的实现了事务。

## MySQL 数据库和 SQL
性能是一个综合性的问题：吞吐和延迟可以是正相关，也可以是负相关（想象一根很粗但是很长的水管，高吞吐高延迟）。性能优化的要点是先量化并遵循80/20原则。

Mysql数据库使用中是有很多需要考虑的点，比如说：
1. innodb的参数配置优化：max_connections, backlog,wait_timeout等等，
2. 数据库的优化：唯一约束和索引的关系，是否需要冗余字段，自增主键， 物理删除还是逻辑删除，create_time和update_time等等。

事务也是必须着重考虑的点：ACID, MYSQL的隔离级别有：串行化(最严格) -> 可重复读（默认） -> 读已提交 ->读未提交 （最不严格）， MySql通过
undo log来保证事务的原子性和redo log来保证事务的持久性，通过MVCC来支持可重复读和读已提交，并极大的增加了并发的性能。

从性能上还必须注意数据类型的选择，隐形转换的开销，写入优化，数据更新，模糊查询，连接查询，索引失效等等问题。

## 分库分表
数据库的拆分是由于数据规模和高并发访问造成的。两者通常同时出现。如果仅仅是高并发访问，由于通常读操作要多于写操作，可以用主从复制的方式来解决。

写性能的瓶颈就必须要用分库分表来解决。降低单个节点的写压力。分库分表还分为水平拆分和垂直拆分。垂直拆分是通过微服务来实现的而
水平拆分则可以是对任意数据进行。分库分表可以解决容量问题，提供性能和稳定性，但是对业务有侵入性，并有数据迁移的难度，还带来强一致的实现上的挑战。

这些问题可以通过数据库中间件比如ShardingSphere来解决。

## RPC 和微服务
RPC是远程过程调用（Remote Procedure Call）的缩写形式。RPC的核心是代理机制。它提供了以下功能的代理
1.本地代理存根: Stub
2.本地序列化反序列化
3.网络通信
4.远程序列化反序列化
5.远程服务存根: Skeleton
6.调用实际业务服务
7.原路返回服务结果
8.返回给本地调用方

常见的RPC技术有Hessian， Thrift和gRPC. 分布式业务中RPC服务仅仅是一小部分需要提供的服务所以渐渐地从提供单一的RPC服务的需求演化成一个微服务架构的需求，
包含了分布式服务治理，配置/注册/元数据中心，服务的注册与发现，服务的集群与路由， 服务的过滤与流控。Spring Cloud和Dubbo就是一个微服务框架，

## 分布式缓存
数据根据使用频率和方式分类。对于读频率高于写频率的数据可以适用缓存的方式来访问。它是提升系统性能的一个简单有效的办法。
缓存加载时机： 启动全量加载， 懒加载（同步使用加载，延迟异步加载）。缓存使用不当会产生系统预热导致启动慢，系统内存资源耗尽，数据不一致的问题。
缓存还分为本地缓存(hashmap, guava cache, spring cache) 和远程缓存(Redis,Memcached).
缓存的一大问题就是过期，通常的过期策略:按FIFO或LRU, 按固定时间过期, 按业务时间加权：例如3+5x


## 分布式消息队列
系统间通信方式： 文件，Socket，数据库，和RPC。
Message Queue是一种异步的消息通信，并简化参与各方的复杂依赖关系，还可以在在请求量很大的时候起到缓冲的作用。并能保障消息的可靠性和顺序。

MQ的四大作用
- 异步通信：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作。
- 系统解耦：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成。
- 削峰平谷：压力大的时候，缓冲部分请求消息，类似于背压处理。
- 可靠通信：提供多种消息模式、服务质量、顺序保障等。

Kafka消息中间件的介绍包含其持久化能力，高吞吐，顺序传输，水平扩展等等特点。
Kafka的基本概念有broker, topic, partition, producer, consumer, consumer group.
kafka可以是单机模式或者通过ZK实现集群安装部署

常见的MQ还有ActiveMQ， RabbitMQ，RocketMQ，Pulsar等等

![脑图](https://raw.githubusercontent.com/allen1128/JAVA-000/main/Final/overview.png)
